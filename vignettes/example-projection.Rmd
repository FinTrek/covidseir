---
title: "Example model fitting and projections"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{example-projection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warnings = FALSE,
  fig.width = 5,
  dpi = 125
)
```

Load some libraries and set up parallel processing:

```{r setup}
library(covidseir)
library(ggplot2)
library(dplyr)
options(mc.cores = parallel::detectCores() / 2) # Stan parallel processing
library(future)
plan(multisession, workers = parallel::detectCores() / 2)
```

Let's read in the data:

```{r}
cases <- c(
  0, 0, 1, 3, 1, 8, 0, 6, 5, 0, 7, 7, 18, 9, 22, 38, 53, 45, 40,
  77, 76, 48, 67, 78, 42, 66, 67, 92, 16, 70, 43, 53, 55, 53, 29,
  26, 37, 25, 45, 34, 40, 35
)
hosp <- c(
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 11, 9, 4,
  7, 19, 23, 13, 11, 3, 13, 21, 14, 17, 29, 21, 19, 19, 10, 6,
  11, 8, 11, 8, 7, 6
)
stopifnot(length(cases) == length(hosp))
dat <- tibble(
  cases = c(cases, hosp),
  type = rep(c("daily_cases", "daily_hospital"), each = length(hosp)),
  day = c(1:length(hosp), 1:length(hosp)),
  date = rep(seq(lubridate::ymd("2020-03-01"),
    lubridate::ymd("2020-03-01") + length(hosp) - 1,
    by = "1 day"
  ), 2)
)

s1 <- c(rep(0.1, 13), rep(0.2, length(cases) - 13)) # example sample fractions
s2 <- rep(0.05, length(hosp)) # example sample fractions
```

We can fit the Stan model with the function `fit_seeiqr()`. It takes one data input: a vector of case counts. This could also represent new hospital cases. We will only use 200 iterations and 1 chain so that this example runs quickly, but you would likely want more if you want stability in the tails of the posterior distribution. 8000 total iterations should be plenty, broken up across however many chains you can use efficiently on your available cores (e.g. 8 chains and 1000 iterations or 4 chains and 2000 iterations).

Stan will run in parallel assuming `options(mc.cores = parallel::detectCores() / 2)` was set. For the purposes of this vignette, we will just run one chain.

```{r fit, message=FALSE, results='hide'}
m1 <- fit_seir(
  cases,
  iter = 200,
  chains = 1,
  sampled_fractions = s1,
  delayScale = 9.85,
  delayShape = 1.73
)
```

If we had fit the above model with `save_state_predictions = TRUE`, then we could visualize the state predictions with the following code. We won't do that here, since we will re-project the states in R afterwards. Running the model with `save_state_predictions = TRUE` will result in a much larger model object that is slower to work with.

```{r, eval=FALSE}
if ("y_hat" %in% names(m1$post)) {
  post_state <- m1$fit %>%
    tidybayes::spread_draws(y_hat[time_num, state_num], n = 20)
  variables_df <- tibble(
    state = names(m1$state_0),
    state_num = seq_along(m1$state_0)
  )
  ts_df <- dplyr::tibble(time = m1$time, time_num = seq_along(m1$time))
  post_state <- left_join(post_state, variables_df)
  post_state <- left_join(post_state, ts_df)
  ggplot(post_state, aes(time, y_hat, group = paste(.iteration, .draw))) +
    geom_line(alpha = 0.25) +
    facet_wrap(~state, scales = "free_y")
}
```

Posterior predictive replicates are available in `post$y_rep`. We can also build those ourselves afterwards in R (shown below).

Draws from the expected number of cases `lambda_d` are available as well.

```{r}
post_mu <- m1$fit %>% tidybayes::spread_draws(lambda_d[day, data_type])
post_y_rep <- m1$fit %>% tidybayes::spread_draws(y_rep[day, data_type])

ggplot(post_mu, aes(day, lambda_d, group = paste(.iteration, .draw))) +
  geom_line(alpha = 0.05) +
  facet_wrap(~data_type) +
  geom_point(
    data = filter(dat, type == "daily_cases"), aes(x = day, y = cases),
    inherit.aes = FALSE
  )

ggplot(post_y_rep, aes(day, y_rep, group = paste(.iteration, .draw))) +
  geom_line(alpha = 0.07) +
  facet_wrap(~data_type) +
  geom_line(
    data = filter(dat, type == "daily_cases"), aes(x = day, y = cases),
    inherit.aes = FALSE
  )
```

We can make a quick plot of the model fit:

```{r plot2}
plot_projection(list(m1))
```

If we wanted to control the number of projected days within the Stan fitting function, we could do it like this:

```{r fit2, message=FALSE, results='hide', eval=FALSE}
m_forecast <- fit_seir(cases, iter = 200, chains = 1, forecast_days = 60)
```

There are many named elements of the fitted object. Examples follow.

The posterior samples from `rstan::extract()` are in the element `post` for posterior:

```{r}
names(m1$post)
```

The rstan object itself is in the named element `fit`. You can do anything with that you can do with the output from an rstan fit.

```{r}
print(m1$fit, pars = c("R0", "f2", "phi"))
```

I have named the parameters I want to look up to avoid summarizing many derived values and parameters.

A couple examples of things you could do:

```{r}
bayesplot::mcmc_areas(m1$fit, pars = c("R0", "f2", "phi[1]"))
bayesplot::mcmc_trace(m1$fit, pars = c("R0", "f2", "phi[1]"))
```

```{r, eval=FALSE}
shinystan::launch_shinystan(m1$fit)
```

The ODE state predictions are only available if `fit_seeiqr()` is fit with the option `save_state_predictions = TRUE`. This will make the resulting model object considerably larger in the model will take a little bit longer to fit. By default it is false.

The other elements of the output object are mostly information on how the model was fitted. 
It's helpful for debugging purposes, to know that the data, exactly as it was passed to Stan, are in the element `stan_data`:

```{r}
names(m1$stan_data)
```

# Making projections directly in R

There is a helper function `project_fit()`, which allows you to take the parameter estimates from the fitted function and pass them through similar functions in R to get output from the ODE solver and predicted case counts. This is particularly useful if you want to project into the future while manipulating the `f2` values in the future (and you don't want to bog down Stan or have to refit the model every time you want to make a different type of projection). Plus, this gives you a lot more flexibility but what you want to do with `f` in the projections.

Aside: most of the submitted pre-print just uses Stan for all the predictions and fits the model over and over. That's fine too, but just takes longer.

Let's start by using the R functions to generate the same predictions that we could have got out of our fit to the historical data:

```{r}
proj <- project_fit(m1)
head(proj$states)
head(proj$cases)

ggplot(proj$states, aes(time, I + Id, group = iterations)) +
  geom_line(alpha = 0.3)
ggplot(proj$cases, aes(day, lambda_d, group = iterations)) +
  geom_line(alpha = 0.3)
ggplot(proj$cases, aes(day, y_rep, group = iterations)) +
  geom_line(alpha = 0.3)

proj$states %>%
  tidyr::pivot_longer(-c(time, iterations)) %>%
  ggplot(aes(time, value, group = iterations)) +
  geom_line(alpha = 0.2) +
  facet_wrap(~name, scales = "free_y")
```

By default, `project_fit()` only uses 50 samples from the posterior. This may be enough for some visualizations, but probably isn't enough for coming up with consistent credible intervals on projections.

The function `project_fit()` also takes an argument `f_vec`, which should be a vector of `f` values of at least the same length as the number of days that will be predicted (starting from day 1).

Here's an example of cycling between f = 0.8 and f = 0.3 at 4-week intervals:

```{r}
f_vec <- c(
  rep(NA, m1$last_day_obs),
  rep(c(rep(0.8, 7 * 4), rep(0.3, 7 * 4)), 3)
)
f_vec
proj2 <- project_fit(m1, f_vec = f_vec, proj_days = 90, i = 1:20)

ggplot(proj2$states, aes(time, I + Id, group = iterations)) +
  geom_line(alpha = 0.3)
ggplot(proj2$cases, aes(day, lambda_d, group = iterations)) +
  geom_line(alpha = 0.3)
ggplot(proj2$cases, aes(day, y_rep, group = iterations)) +
  geom_line(alpha = 0.3)
```

# Using the projection plot function

You can use the output data to make whatever plots you would like. However, there's also a function for making some of the projection plots from the pre-print:

```{r}
plot_projection(m1)
```

Note that it can take a list object as input. This is so that you can provide a list of multiple models and it will arrange them as multiple panels in one plot. The names of the list elements become the facet labels. If you only have one model, you will need to provide it as a list.

For example:

```{r}
plot_projection(list("One model" = m1, "Another model" = m1))
```

Obviously these are both actually the same model in this case, but they could be named list output from `purrr::map()` or `lapply()`.

By default it takes the projections directly from the Stan object. You can also override that if you want to provide your own predictions.

Sorry I haven't wrapped up these functions yet. FIXME

```{r}
prep_dat <- function(.dat, Scenario = "") {
  actual_dates <- seq(dat$date[1], max(dat$date[1]) + 90, by = "1 day")
  outer_quantile <- c(0.05, 0.95)
  y_rep <- .dat %>%
    mutate(value = y_rep) %>%
    group_by(day) %>%
    summarise(
      lwr = quantile(value, probs = outer_quantile[1]),
      lwr2 = quantile(value, probs = 0.25),
      upr = quantile(value, probs = outer_quantile[2]),
      upr2 = quantile(value, probs = 0.75),
      med = median(value)
    ) %>%
    mutate(day = actual_dates[day], Scenario = Scenario)
  lambdas <- .dat %>%
    group_by(day) %>%
    mutate(value = lambda_d) %>%
    summarise(
      med = median(value)
    ) %>%
    mutate(day = actual_dates[day], Scenario = Scenario)
  list(y_rep = y_rep, mu = lambdas)
}
# Re-sample the observation component for smoother credible intervals:
proj_replicated <- purrr::map_dfr(1:30, function(i) {
  temp <- proj2$cases
  temp$y_rep <- MASS::rnegbin(length(temp$y_rep),
    temp$lambda_d,
    theta = temp$phi
  )
  temp
})
x <- prep_dat(proj_replicated)
```

```{r, warnings = FALSE, include=FALSE, eval=FALSE}
plot_projection(
  m1,
  mu_dat = x$mu,
  y_rep_dat = x$y_rep
)
```

# Multiple data types

We can extend the model to include multiple response data types (e.g., daily case counts and daily hospitalizations) by including a matrix of daily cases. We also then have to include a matrix of sampled fractions and a vector of delay scale and shape parameters to match:

```{r fit2types, message=FALSE, results='hide'}
s1 <- c(rep(0.1, 13), rep(0.2, length(cases) - 13)) # example sample fractions
s2 <- rep(0.05, length(hosp)) # example sample fractions

m2 <- fit_seir(
  daily_cases = cbind(cases, hosp),
  iter = 200,
  chains = 1,
  sampled_fractions = cbind(s1, s2),
  delayScale = c(9.85, 10.15),
  delayShape = c(1.73, 1.93),
)
```

```{r}
plot_projection(m2)
```
